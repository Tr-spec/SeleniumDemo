1672067047684	geckodriver	INFO	Listening on 127.0.0.1:63064
1672067050704	mozrunner::runner	INFO	Running command: "C:\\Program Files\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "63065" "--remote-allow-hosts" "localhost" "-no-remote" "-profile" "C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofilervQtxz"
1672067053340	Marionette	INFO	Marionette enabled
1672067053357	Marionette	INFO	Listening on port 63077
Read port: 63077
WebDriver BiDi listening on ws://127.0.0.1:63065
1672067053672	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofilervQtxz\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:63065/devtools/browser/626b35e3-4d60-4e27-8f17-a93c28dba869
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://demo.nopcommerce.com."
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://demo.nopcommerce.com."
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://demo.nopcommerce.com."
console.error: (new TypeError("currentNode is null", "resource://devtools/client/inspector/shared/style-change-tracker.js", 66))
TypeError: currentNode is null: canMutationImpactCurrentStyles@resource://devtools/client/inspector/shared/style-change-tracker.js:66:20
onMutations@resource://devtools/client/inspector/shared/style-change-tracker.js:84:41
_emit@resource://devtools/shared/event-emitter.js:242:32
emit@resource://devtools/shared/event-emitter.js:186:18
emit@resource://devtools/shared/event-emitter.js:330:18
getMutations@resource://devtools/client/fronts/walker.js:313:10

console.error: "Error when attaching target:" (new Error("Connection closed, pending request to server0.conn0.windowGlobal4294967303/thread1, type isAttached failed\n\nRequest stack:\nrequest@resource://devtools/shared/protocol/Front.js:300:14\ngenerateRequestMethods/</frontProto[name]@resource://devtools/shared/protocol/Front/FrontClassWithSpec.js:47:19\nattachThread@resource://devtools/client/fronts/targets/target-mixin.js:566:49\n", "resource://devtools/shared/protocol/Front.js", 106))
Handler function threw an exception: [Exception... "Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]"  nsresult: "0x80040111 (NS_ERROR_NOT_AVAILABLE)"  location: "JS frame :: resource://devtools/server/actors/targets/window-global.js :: watch :: line 1664"  data: no]
Stack: watch@resource://devtools/server/actors/targets/window-global.js:1664:28
_watchDocshells@resource://devtools/server/actors/targets/window-global.js:779:28
initialize/<@resource://devtools/server/actors/targets/window-global.js:348:42
exports.makeInfallible/<@resource://devtools/shared/ThreadSafeDevToolsUtils.js:103:22
Line: 1664, column: 0
console.error: ({})
console.error: "Error while calling actor 'thread's method 'isAttached'" "JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment"
console.error: (new InvalidStateError("JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment", (void 0), 376))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
console.error: "Error when destroying StyleSheet manager for" ({conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, actorID:"server0.conn0.windowGlobal4294967303/windowGlobalTarget2", _actorSpec:{typeName:"windowGlobalTarget", methods:[{name:"detach", request:{type:"detach", template:{type:"detach"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"ensureCSSErrorReportingEnabled", request:{type:"ensureCSSErrorReportingEnabled", template:{type:"ensureCSSErrorReportingEnabled"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"focus", request:{type:"focus", template:{type:"focus"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"goForward", request:{type:"goForward", template:{type:"goForward"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"goBack", request:{type:"goBack", template:{type:"goBack"}, args:[]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reload", request:{type:"reload", template:{type:"reload", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"navigateTo", request:{type:"navigateTo", template:{type:"navigateTo", url:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["url"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"switchToFrame", request:{type:"switchToFrame", template:{type:"switchToFrame", windowId:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["windowId"]}]}, response:{template:{_type:"windowGlobalTarget.switchtoframe", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.switchtoframe", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"listFrames", request:{type:"listFrames", template:{type:"listFrames"}, args:[]}, response:{template:{_type:"windowGlobalTarget.listframes", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.listframes", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"listWorkers", request:{type:"listWorkers", template:{type:"listWorkers"}, args:[]}, response:{template:{_type:"windowGlobalTarget.workers", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"windowGlobalTarget.workers", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"logInPage", request:{type:"logInPage", template:{type:"logInPage", text:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, category:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, flags:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["text"]}, {placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["category"]}, {placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["flags"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}], events:{}}, docShell:({}), _originalWindow:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get applicationCache() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, sizeToContentConstrained:function sizeToContentConstrained() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, isPrivate:false, followWindowGlobalLifeCycle:true, isTopLevelTarget:false, ignoreSubFrames:true, sessionContext:{type:"browser-element", browserId:7, isServerTargetSwitchingEnabled:true, isPopupDebuggingEnabled:false, supportedTargets:{frame:true, process:true, worker:true}, supportedResources:{'console-message':true, 'css-change':true, 'css-message':true, 'document-event':true, Cache:true, cookies:true, 'error-message':true, 'indexed-db':true, 'local-storage':true, 'session-storage':true, 'platform-message':true, 'network-event':true, 'network-event-stacktrace':true, reflow:true, stylesheet:true, source:true, 'thread-state':true, 'server-sent-event':true, websocket:true}}, _extraActors:{consoleActor:{_options:{id:"devtools/server/actors/webconsole", prefix:"console", constructorName:"WebConsoleActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"consoleActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"consoleActor", actorID:"server0.conn0.windowGlobal4294967303/consoleActor3", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, inspectorActor:{_options:{id:"devtools/server/actors/inspector/inspector", prefix:"inspector", constructorName:"InspectorActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"inspectorActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"inspectorActor", actorID:"server0.conn0.windowGlobal4294967303/inspectorActor4", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, styleSheetsActor:{_options:{id:"devtools/server/actors/style-sheets", prefix:"styleSheets", constructorName:"StyleSheetsActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"styleSheetsActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"styleSheetsActor", actorID:"server0.conn0.windowGlobal4294967303/styleSheetsActor5", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, storageActor:{_options:{id:"devtools/server/actors/storage", prefix:"storage", constructorName:"StorageActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"storageActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"storageActor", actorID:"server0.conn0.windowGlobal4294967303/storageActor6", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, memoryActor:{_options:{id:"devtools/server/actors/memory", prefix:"memory", constructorName:"MemoryActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"memoryActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"memoryActor", actorID:"server0.conn0.windowGlobal4294967303/memoryActor7", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, reflowActor:{_options:{id:"devtools/server/actors/reflow", prefix:"reflow", constructorName:"ReflowActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"reflowActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"reflowActor", actorID:"server0.conn0.windowGlobal4294967303/reflowActor8", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, cssPropertiesActor:{_options:{id:"devtools/server/actors/css-properties", prefix:"cssProperties", constructorName:"CssPropertiesActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"cssPropertiesActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"cssPropertiesActor", actorID:"server0.conn0.windowGlobal4294967303/cssPropertiesActor9", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, animationsActor:{_options:{id:"devtools/server/actors/animation", prefix:"animations", constructorName:"AnimationsActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"animationsActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"animationsActor", actorID:"server0.conn0.windowGlobal4294967303/animationsActor10", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, responsiveActor:{_options:{id:"devtools/server/actors/emulation/responsive", prefix:"responsive", constructorName:"ResponsiveActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"responsiveActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"responsiveActor", actorID:"server0.conn0.windowGlobal4294967303/responsiveActor11", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, webExtensionInspectedWindowActor:{_options:{id:"devtools/server/actors/addon/webextension-inspected-window", prefix:"webExtensionInspectedWindow", constructorName:"WebExtensionInspectedWindowActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"webExtensionInspectedWindowActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"webExtensionInspectedWindowActor", actorID:"server0.conn0.windowGlobal4294967303/webExtensionInspectedWindowActor12", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, accessibilityActor:{_options:{id:"devtools/server/actors/accessibility/accessibility", prefix:"accessibility", constructorName:"AccessibilityActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"accessibilityActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"accessibilityActor", actorID:"server0.conn0.windowGlobal4294967303/accessibilityActor13", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, changesActor:{_options:{id:"devtools/server/actors/changes", prefix:"changes", constructorName:"ChangesActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"changesActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"changesActor", actorID:"server0.conn0.windowGlobal4294967303/changesActor14", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, webSocketActor:{_options:{id:"devtools/server/actors/network-monitor/websocket-actor", prefix:"webSocket", constructorName:"WebSocketActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"webSocketActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"webSocketActor", actorID:"server0.conn0.windowGlobal4294967303/webSocketActor15", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, eventSourceActor:{_options:{id:"devtools/server/actors/network-monitor/eventsource-actor", prefix:"eventSource", constructorName:"EventSourceActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"eventSourceActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"eventSourceActor", actorID:"server0.conn0.windowGlobal4294967303/eventSourceActor16", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, manifestActor:{_options:{id:"devtools/server/actors/manifest", prefix:"manifest", constructorName:"ManifestActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"manifestActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"manifestActor", actorID:"server0.conn0.windowGlobal4294967303/manifestActor17", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, networkContentActor:{_options:{id:"devtools/server/actors/network-monitor/network-content", prefix:"networkContent", constructorName:"NetworkContentActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"networkContentActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"networkContentActor", actorID:"server0.conn0.windowGlobal4294967303/networkContentActor18", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}, screenshotContentActor:{_options:{id:"devtools/server/actors/screenshot-content", prefix:"screenshotContent", constructorName:"ScreenshotContentActor", type:{target:true}, globalActor:(void 0), targetScopedActor:true}, _parentActor:{}, _name:"screenshotContentActor", _pool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, typeName:"screenshotContentActor", actorID:"server0.conn0.windowGlobal4294967303/screenshotContentActor19", parentPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}}}, _sourcesManager:{_thread:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, actorID:"server0.conn0.windowGlobal4294967303/thread1", _actorSpec:{typeName:"thread", methods:[{name:"attach", request:{type:"attach", template:{type:"attach", options:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, args:[{placeholder:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"resume", request:{type:"resume", template:{type:"resume", resumeLimit:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, frameActorID:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["resumeLimit"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["frameActorID"]}]}, response:{template:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"frames", request:{type:"frames", template:{type:"frames", start:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, count:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["start"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["count"]}]}, response:{template:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"interrupt", request:{type:"interrupt", template:{type:"interrupt", when:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["when"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"sources", request:{type:"sources", template:{type:"sources"}, args:[]}, response:{template:{sources:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["sources"]}, release:(void 0), oneway:(void 0)}, {name:"skipBreakpoints", request:{type:"skipBreakpoints", template:{type:"skipBreakpoints", skip:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["skip"]}]}, response:{template:{skip:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}}, release:(void 0), oneway:(void 0)}, {name:"dumpThread", request:{type:"dumpThread", template:{type:"dumpThread"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"dumpPools", request:{type:"dumpPools", template:{type:"dumpPools"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"setBreakpoint", request:{type:"setBreakpoint", template:{type:"setBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, options:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"removeBreakpoint", request:{type:"removeBreakpoint", template:{type:"removeBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"setXHRBreakpoint", request:{type:"setXHRBreakpoint", template:{type:"setXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"removeXHRBreakpoint", request:{type:"removeXHRBreakpoint", template:{type:"removeXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getAvailableEventBreakpoints", request:{type:"getAvailableEventBreakpoints", template:{type:"getAvailableEventBreakpoints"}, args:[]}, response:{template:{value:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getActiveEventBreakpoints", request:{type:"getActiveEventBreakpoints", template:{type:"getActiveEventBreakpoints"}, args:[]}, response:{template:{ids:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}, release:(void 0), oneway:(void 0)}, {name:"setActiveEventBreakpoints", request:{type:"setActiveEventBreakpoints", template:{type:"setActiveEventBreakpoints", ids:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"pauseOnExceptions", request:{type:"pauseOnExceptions", template:{type:"pauseOnExceptions", pauseOnExceptions:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, ignoreCaughtExceptions:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["pauseOnExceptions"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ignoreCaughtExceptions"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"toggleEventLogging", request:{type:"toggleEventLogging", template:{type:"toggleEventLogging", logEventBreakpoints:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["logEventBreakpoints"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"isAttached", request:{type:"isAttached", template:{type:"isAttached"}, args:[]}, response:{template:{value:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, retVal:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["value"]}, release:(void 0), oneway:(void 0)}], events:{}}, _state:"running", _parent:{}, global:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get applicationCache() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, sizeToContentConstrained:function sizeToContentConstrained() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, _options:{skipBreakpoints:false, pauseOnExceptions:false, ignoreCaughtExceptions:true, shouldShowOverlay:true, shouldIncludeSavedFrames:true, shouldIncludeAsyncLiveFrames:false, logEventBreakpoints:false, observeAsmJS:true}, _gripDepth:0, _parentClosed:false, _observingNetwork:false, _frameActors:[], _xhrBreakpoints:[], _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _threadLifetimePool:null, _activeEventPause:null, _pauseOverlay:null, _priorPause:null, _activeEventBreakpoints:{}, _frameActorMap:{}, _debuggerSourcesSeen:{}, _onLoadBreakpointURLs:{}, _handledFrameExceptions:{}, _watchpointsMap:{threadActor:{}, _watchpoints:{}}, breakpointActorMap:{_threadActor:{}, _actors:{}}, _nestedEventLoop:{_thread:{}, _entered:false, _resolved:false}, onNewSourceEvent:function bound onNewSourceEvent() {
    [native code]
}, createCompletionGrip:function bound createCompletionGrip() {
    [native code]
}, onDebuggerStatement:function bound onDebuggerStatement() {
    [native code]
}, onNewScript:function bound onNewScript() {
    [native code]
}, objectGrip:function bound objectGrip() {
    [native code]
}, pauseObjectGrip:function bound pauseObjectGrip() {
    [native code]
}, _onOpeningRequest:function bound _onOpeningRequest() {
    [native code]
}, _onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}, _onExceptionUnwind:function bound _onExceptionUnwind() {
    [native code]
}, _eventBreakpointListener:function bound _eventBreakpointListener() {
    [native code]
}, _onWindowReady:function bound _onWindowReady() {
    [native code]
}, _onWillNavigate:function bound _onWillNavigate() {
    [native code]
}, _onNavigate:function bound _onNavigate() {
    [native code]
}, _firstStatementBreakpoint:null, _debuggerNotificationObserver:{}, parentPool:{}, alreadyAttached:true, wrappedJSObject:{}, _shouldEmitNewSource:false, _pendingResponse:{}, [Symbol("EventEmitter/listeners")]:{}}, blackBoxedSources:{}, _sourceActors:{}, _urlContents:{}, _urlWaiters:{}, _sourcesByInternalSourceId:null, [Symbol("EventEmitter/listeners")]:{}}, _styleSheetActors:{}, _shouldAddNewGlobalAsDebuggee:function bound _shouldAddNewGlobalAsDebuggee() {
    [native code]
}, makeDebugger:function bound makeDebugger() {
    [native code]
}, watchNewDocShells:false, _workerDescriptorActorList:null, _workerDescriptorActorPool:null, _onWorkerDescriptorActorListChanged:function bound _onWorkerDescriptorActorListChanged() {
    [native code]
}, _onConsoleApiProfilerEvent:function bound _onConsoleApiProfilerEvent() {
    [native code]
}, threadActor:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {conn:{}, __poolMap:{}}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, actorID:"server0.conn0.windowGlobal4294967303/thread1", _actorSpec:{typeName:"thread", methods:[{name:"attach", request:{type:"attach", template:{type:"attach", options:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, args:[{placeholder:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"reconfigure", request:{type:"reconfigure", template:{type:"reconfigure", options:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"resume", request:{type:"resume", template:{type:"resume", resumeLimit:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, frameActorID:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["resumeLimit"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["frameActorID"]}]}, response:{template:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"nullable:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"frames", request:{type:"frames", template:{type:"frames", start:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, count:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["start"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["count"]}]}, response:{template:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"thread.frames", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"interrupt", request:{type:"interrupt", template:{type:"interrupt", when:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["when"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"sources", request:{type:"sources", template:{type:"sources"}, args:[]}, response:{template:{sources:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["sources"]}, release:(void 0), oneway:(void 0)}, {name:"skipBreakpoints", request:{type:"skipBreakpoints", template:{type:"skipBreakpoints", skip:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["skip"]}]}, response:{template:{skip:{index:0, type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"json", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}}, release:(void 0), oneway:(void 0)}, {name:"dumpThread", request:{type:"dumpThread", template:{type:"dumpThread"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"dumpPools", request:{type:"dumpPools", template:{type:"dumpPools"}, args:[]}, response:{template:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, retVal:{_type:"json", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:[]}, release:(void 0), oneway:(void 0)}, {name:"setBreakpoint", request:{type:"setBreakpoint", template:{type:"setBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, options:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["options"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"removeBreakpoint", request:{type:"removeBreakpoint", template:{type:"removeBreakpoint", location:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["location"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"setXHRBreakpoint", request:{type:"setXHRBreakpoint", template:{type:"setXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"removeXHRBreakpoint", request:{type:"removeXHRBreakpoint", template:{type:"removeXHRBreakpoint", path:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, method:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["path"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["method"]}]}, response:{template:{value:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"boolean", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getAvailableEventBreakpoints", request:{type:"getAvailableEventBreakpoints", template:{type:"getAvailableEventBreakpoints"}, args:[]}, response:{template:{value:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:available-breakpoint-group", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["value"]}, release:(void 0), oneway:(void 0)}, {name:"getActiveEventBreakpoints", request:{type:"getActiveEventBreakpoints", template:{type:"getActiveEventBreakpoints"}, args:[]}, response:{template:{ids:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, retVal:{_type:"array:string", get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}, release:(void 0), oneway:(void 0)}, {name:"setActiveEventBreakpoints", request:{type:"setActiveEventBreakpoints", template:{type:"setActiveEventBreakpoints", ids:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ids"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"pauseOnExceptions", request:{type:"pauseOnExceptions", template:{type:"pauseOnExceptions", pauseOnExceptions:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, ignoreCaughtExceptions:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["pauseOnExceptions"]}, {placeholder:{index:1, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["ignoreCaughtExceptions"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"toggleEventLogging", request:{type:"toggleEventLogging", template:{type:"toggleEventLogging", logEventBreakpoints:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}}, args:[{placeholder:{index:0, get type() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    }}, path:["logEventBreakpoints"]}]}, response:{template:{}}, release:(void 0), oneway:(void 0)}, {name:"isAttached", request:{type:"isAttached", template:{type:"isAttached"}, args:[]}, response:{template:{value:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}}, retVal:{_type:"boolean", type:{toString() {
        return "[protocol type:" + name + "]";
      }, name:"boolean", primitive:true, read:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}, write:function identityWrite(v) {
  if (v === undefined) {
    throw Error("undefined passed where a value is required");
  }
  // This has to handle iterator->array conversion because arrays of
  // primitive types pass through here.
  if (v && typeof v.next === "function") {
    return [...v];
  }
  return v;
}}}, path:["value"]}, release:(void 0), oneway:(void 0)}], events:{}}, _state:"running", _parent:{}, global:{get window() {
    [native code]
}, get document() {
    [native code]
}, get location() {
    [native code]
}, set location() {
    [native code]
}, get top() {
    [native code]
}, close:function close() {
    [native code]
}, stop:function stop() {
    [native code]
}, focus:function focus() {
    [native code]
}, blur:function blur() {
    [native code]
}, open:function open() {
    [native code]
}, alert:function alert() {
    [native code]
}, confirm:function confirm() {
    [native code]
}, prompt:function prompt() {
    [native code]
}, print:function print() {
    [native code]
}, printPreview:function printPreview() {
    [native code]
}, postMessage:function postMessage() {
    [native code]
}, captureEvents:function captureEvents() {
    [native code]
}, releaseEvents:function releaseEvents() {
    [native code]
}, getSelection:function getSelection() {
    [native code]
}, getComputedStyle:function getComputedStyle() {
    [native code]
}, matchMedia:function matchMedia() {
    [native code]
}, moveTo:function moveTo() {
    [native code]
}, moveBy:function moveBy() {
    [native code]
}, resizeTo:function resizeTo() {
    [native code]
}, resizeBy:function resizeBy() {
    [native code]
}, scroll:function scroll() {
    [native code]
}, scrollTo:function scrollTo() {
    [native code]
}, scrollBy:function scrollBy() {
    [native code]
}, getDefaultComputedStyle:function getDefaultComputedStyle() {
    [native code]
}, scrollByLines:function scrollByLines() {
    [native code]
}, scrollByPages:function scrollByPages() {
    [native code]
}, sizeToContent:function sizeToContent() {
    [native code]
}, updateCommands:function updateCommands() {
    [native code]
}, find:function find() {
    [native code]
}, dump:function dump() {
    [native code]
}, setResizable:function setResizable() {
    [native code]
}, requestIdleCallback:function requestIdleCallback() {
    [native code]
}, cancelIdleCallback:function cancelIdleCallback() {
    [native code]
}, getRegionalPrefsLocales:function getRegionalPrefsLocales() {
    [native code]
}, getWebExposedLocales:function getWebExposedLocales() {
    [native code]
}, requestAnimationFrame:function requestAnimationFrame() {
    [native code]
}, cancelAnimationFrame:function cancelAnimationFrame() {
    [native code]
}, reportError:function reportError() {
    [native code]
}, btoa:function btoa() {
    [native code]
}, atob:function atob() {
    [native code]
}, setTimeout:function setTimeout() {
    [native code]
}, clearTimeout:function clearTimeout() {
    [native code]
}, setInterval:function setInterval() {
    [native code]
}, clearInterval:function clearInterval() {
    [native code]
}, queueMicrotask:function queueMicrotask() {
    [native code]
}, createImageBitmap:function createImageBitmap() {
    [native code]
}, structuredClone:function structuredClone() {
    [native code]
}, fetch:function fetch() {
    [native code]
}, get self() {
    [native code]
}, set self() {
    [native code]
}, get name() {
    [native code]
}, set name() {
    [native code]
}, get history() {
    [native code]
}, get customElements() {
    [native code]
}, get locationbar() {
    [native code]
}, set locationbar() {
    [native code]
}, get menubar() {
    [native code]
}, set menubar() {
    [native code]
}, get personalbar() {
    [native code]
}, set personalbar() {
    [native code]
}, get scrollbars() {
    [native code]
}, set scrollbars() {
    [native code]
}, get statusbar() {
    [native code]
}, set statusbar() {
    [native code]
}, get toolbar() {
    [native code]
}, set toolbar() {
    [native code]
}, get status() {
    [native code]
}, set status() {
    [native code]
}, get closed() {
    [native code]
}, get event() {
    [native code]
}, set event() {
    [native code]
}, get frames() {
    [native code]
}, set frames() {
    [native code]
}, get length() {
    [native code]
}, set length() {
    [native code]
}, get opener() {
    [native code]
}, set opener() {
    [native code]
}, get parent() {
    [native code]
}, set parent() {
    [native code]
}, get frameElement() {
    [native code]
}, get navigator() {
    [native code]
}, get clientInformation() {
    [native code]
}, get external() {
    [native code]
}, set external() {
    [native code]
}, get applicationCache() {
    [native code]
}, get screen() {
    [native code]
}, set screen() {
    [native code]
}, get innerWidth() {
    [native code]
}, set innerWidth() {
    [native code]
}, get innerHeight() {
    [native code]
}, set innerHeight() {
    [native code]
}, get scrollX() {
    [native code]
}, set scrollX() {
    [native code]
}, get pageXOffset() {
    [native code]
}, set pageXOffset() {
    [native code]
}, get scrollY() {
    [native code]
}, set scrollY() {
    [native code]
}, get pageYOffset() {
    [native code]
}, set pageYOffset() {
    [native code]
}, get screenLeft() {
    [native code]
}, set screenLeft() {
    [native code]
}, get screenTop() {
    [native code]
}, set screenTop() {
    [native code]
}, get screenX() {
    [native code]
}, set screenX() {
    [native code]
}, get screenY() {
    [native code]
}, set screenY() {
    [native code]
}, get outerWidth() {
    [native code]
}, set outerWidth() {
    [native code]
}, get outerHeight() {
    [native code]
}, set outerHeight() {
    [native code]
}, get performance() {
    [native code]
}, set performance() {
    [native code]
}, get mozInnerScreenX() {
    [native code]
}, get mozInnerScreenY() {
    [native code]
}, get devicePixelRatio() {
    [native code]
}, set devicePixelRatio() {
    [native code]
}, get scrollMaxX() {
    [native code]
}, set scrollMaxX() {
    [native code]
}, get scrollMaxY() {
    [native code]
}, set scrollMaxY() {
    [native code]
}, get fullScreen() {
    [native code]
}, set fullScreen() {
    [native code]
}, get ondevicemotion() {
    [native code]
}, set ondevicemotion() {
    [native code]
}, get ondeviceorientation() {
    [native code]
}, set ondeviceorientation() {
    [native code]
}, get onabsolutedeviceorientation() {
    [native code]
}, set onabsolutedeviceorientation() {
    [native code]
}, get InstallTrigger() {
    [native code]
}, set InstallTrigger() {
    [native code]
}, get intlUtils() {
    [native code]
}, get visualViewport() {
    [native code]
}, set visualViewport() {
    [native code]
}, get crypto() {
    [native code]
}, get onabort() {
    [native code]
}, set onabort() {
    [native code]
}, get onblur() {
    [native code]
}, set onblur() {
    [native code]
}, get onfocus() {
    [native code]
}, set onfocus() {
    [native code]
}, get onauxclick() {
    [native code]
}, set onauxclick() {
    [native code]
}, get onbeforeinput() {
    [native code]
}, set onbeforeinput() {
    [native code]
}, get oncanplay() {
    [native code]
}, set oncanplay() {
    [native code]
}, get oncanplaythrough() {
    [native code]
}, set oncanplaythrough() {
    [native code]
}, get onchange() {
    [native code]
}, set onchange() {
    [native code]
}, get onclick() {
    [native code]
}, set onclick() {
    [native code]
}, get onclose() {
    [native code]
}, set onclose() {
    [native code]
}, get oncontextmenu() {
    [native code]
}, set oncontextmenu() {
    [native code]
}, get oncuechange() {
    [native code]
}, set oncuechange() {
    [native code]
}, get ondblclick() {
    [native code]
}, set ondblclick() {
    [native code]
}, get ondrag() {
    [native code]
}, set ondrag() {
    [native code]
}, get ondragend() {
    [native code]
}, set ondragend() {
    [native code]
}, get ondragenter() {
    [native code]
}, set ondragenter() {
    [native code]
}, get ondragexit() {
    [native code]
}, set ondragexit() {
    [native code]
}, get ondragleave() {
    [native code]
}, set ondragleave() {
    [native code]
}, get ondragover() {
    [native code]
}, set ondragover() {
    [native code]
}, get ondragstart() {
    [native code]
}, set ondragstart() {
    [native code]
}, get ondrop() {
    [native code]
}, set ondrop() {
    [native code]
}, get ondurationchange() {
    [native code]
}, set ondurationchange() {
    [native code]
}, get onemptied() {
    [native code]
}, set onemptied() {
    [native code]
}, get onended() {
    [native code]
}, set onended() {
    [native code]
}, get onformdata() {
    [native code]
}, set onformdata() {
    [native code]
}, get oninput() {
    [native code]
}, set oninput() {
    [native code]
}, get oninvalid() {
    [native code]
}, set oninvalid() {
    [native code]
}, get onkeydown() {
    [native code]
}, set onkeydown() {
    [native code]
}, get onkeypress() {
    [native code]
}, set onkeypress() {
    [native code]
}, get onkeyup() {
    [native code]
}, set onkeyup() {
    [native code]
}, get onload() {
    [native code]
}, set onload() {
    [native code]
}, get onloadeddata() {
    [native code]
}, set onloadeddata() {
    [native code]
}, get onloadedmetadata() {
    [native code]
}, set onloadedmetadata() {
    [native code]
}, get onloadstart() {
    [native code]
}, set onloadstart() {
    [native code]
}, get onmousedown() {
    [native code]
}, set onmousedown() {
    [native code]
}, get onmouseenter() {
    [native code]
}, set onmouseenter() {
    [native code]
}, get onmouseleave() {
    [native code]
}, set onmouseleave() {
    [native code]
}, get onmousemove() {
    [native code]
}, set onmousemove() {
    [native code]
}, get onmouseout() {
    [native code]
}, set onmouseout() {
    [native code]
}, get onmouseover() {
    [native code]
}, set onmouseover() {
    [native code]
}, get onmouseup() {
    [native code]
}, set onmouseup() {
    [native code]
}, get onwheel() {
    [native code]
}, set onwheel() {
    [native code]
}, get onpause() {
    [native code]
}, set onpause() {
    [native code]
}, get onplay() {
    [native code]
}, set onplay() {
    [native code]
}, get onplaying() {
    [native code]
}, set onplaying() {
    [native code]
}, get onprogress() {
    [native code]
}, set onprogress() {
    [native code]
}, get onratechange() {
    [native code]
}, set onratechange() {
    [native code]
}, get onreset() {
    [native code]
}, set onreset() {
    [native code]
}, get onresize() {
    [native code]
}, set onresize() {
    [native code]
}, get onscroll() {
    [native code]
}, set onscroll() {
    [native code]
}, get onsecuritypolicyviolation() {
    [native code]
}, set onsecuritypolicyviolation() {
    [native code]
}, get onseeked() {
    [native code]
}, set onseeked() {
    [native code]
}, get onseeking() {
    [native code]
}, set onseeking() {
    [native code]
}, get onselect() {
    [native code]
}, set onselect() {
    [native code]
}, get onslotchange() {
    [native code]
}, set onslotchange() {
    [native code]
}, get onstalled() {
    [native code]
}, set onstalled() {
    [native code]
}, get onsubmit() {
    [native code]
}, set onsubmit() {
    [native code]
}, get onsuspend() {
    [native code]
}, set onsuspend() {
    [native code]
}, get ontimeupdate() {
    [native code]
}, set ontimeupdate() {
    [native code]
}, get onvolumechange() {
    [native code]
}, set onvolumechange() {
    [native code]
}, get onwaiting() {
    [native code]
}, set onwaiting() {
    [native code]
}, get onselectstart() {
    [native code]
}, set onselectstart() {
    [native code]
}, get onselectionchange() {
    [native code]
}, set onselectionchange() {
    [native code]
}, get ontoggle() {
    [native code]
}, set ontoggle() {
    [native code]
}, get onpointercancel() {
    [native code]
}, set onpointercancel() {
    [native code]
}, get onpointerdown() {
    [native code]
}, set onpointerdown() {
    [native code]
}, get onpointerup() {
    [native code]
}, set onpointerup() {
    [native code]
}, get onpointermove() {
    [native code]
}, set onpointermove() {
    [native code]
}, get onpointerout() {
    [native code]
}, set onpointerout() {
    [native code]
}, get onpointerover() {
    [native code]
}, set onpointerover() {
    [native code]
}, get onpointerenter() {
    [native code]
}, set onpointerenter() {
    [native code]
}, get onpointerleave() {
    [native code]
}, set onpointerleave() {
    [native code]
}, get ongotpointercapture() {
    [native code]
}, set ongotpointercapture() {
    [native code]
}, get onlostpointercapture() {
    [native code]
}, set onlostpointercapture() {
    [native code]
}, get onmozfullscreenchange() {
    [native code]
}, set onmozfullscreenchange() {
    [native code]
}, get onmozfullscreenerror() {
    [native code]
}, set onmozfullscreenerror() {
    [native code]
}, get onanimationcancel() {
    [native code]
}, set onanimationcancel() {
    [native code]
}, get onanimationend() {
    [native code]
}, set onanimationend() {
    [native code]
}, get onanimationiteration() {
    [native code]
}, set onanimationiteration() {
    [native code]
}, get onanimationstart() {
    [native code]
}, set onanimationstart() {
    [native code]
}, get ontransitioncancel() {
    [native code]
}, set ontransitioncancel() {
    [native code]
}, get ontransitionend() {
    [native code]
}, set ontransitionend() {
    [native code]
}, get ontransitionrun() {
    [native code]
}, set ontransitionrun() {
    [native code]
}, get ontransitionstart() {
    [native code]
}, set ontransitionstart() {
    [native code]
}, get onwebkitanimationend() {
    [native code]
}, set onwebkitanimationend() {
    [native code]
}, get onwebkitanimationiteration() {
    [native code]
}, set onwebkitanimationiteration() {
    [native code]
}, get onwebkitanimationstart() {
    [native code]
}, set onwebkitanimationstart() {
    [native code]
}, get onwebkittransitionend() {
    [native code]
}, set onwebkittransitionend() {
    [native code]
}, get u2f() {
    [native code]
}, set u2f() {
    [native code]
}, get onerror() {
    [native code]
}, set onerror() {
    [native code]
}, get speechSynthesis() {
    [native code]
}, get onafterprint() {
    [native code]
}, set onafterprint() {
    [native code]
}, get onbeforeprint() {
    [native code]
}, set onbeforeprint() {
    [native code]
}, get onbeforeunload() {
    [native code]
}, set onbeforeunload() {
    [native code]
}, get onhashchange() {
    [native code]
}, set onhashchange() {
    [native code]
}, get onlanguagechange() {
    [native code]
}, set onlanguagechange() {
    [native code]
}, get onmessage() {
    [native code]
}, set onmessage() {
    [native code]
}, get onmessageerror() {
    [native code]
}, set onmessageerror() {
    [native code]
}, get onoffline() {
    [native code]
}, set onoffline() {
    [native code]
}, get ononline() {
    [native code]
}, set ononline() {
    [native code]
}, get onpagehide() {
    [native code]
}, set onpagehide() {
    [native code]
}, get onpageshow() {
    [native code]
}, set onpageshow() {
    [native code]
}, get onpopstate() {
    [native code]
}, set onpopstate() {
    [native code]
}, get onrejectionhandled() {
    [native code]
}, set onrejectionhandled() {
    [native code]
}, get onstorage() {
    [native code]
}, set onstorage() {
    [native code]
}, get onunhandledrejection() {
    [native code]
}, set onunhandledrejection() {
    [native code]
}, get onunload() {
    [native code]
}, set onunload() {
    [native code]
}, get ongamepadconnected() {
    [native code]
}, set ongamepadconnected() {
    [native code]
}, get ongamepaddisconnected() {
    [native code]
}, set ongamepaddisconnected() {
    [native code]
}, get localStorage() {
    [native code]
}, get origin() {
    [native code]
}, set origin() {
    [native code]
}, get crossOriginIsolated() {
    [native code]
}, get isSecureContext() {
    [native code]
}, get indexedDB() {
    [native code]
}, get caches() {
    [native code]
}, get sessionStorage() {
    [native code]
}, mozScrollSnap:function mozScrollSnap() {
    [native code]
}, sizeToContentConstrained:function sizeToContentConstrained() {
    [native code]
}, openDialog:function openDialog() {
    [native code]
}, getInterface:function getInterface() {
    [native code]
}, shouldReportForServiceWorkerScope:function shouldReportForServiceWorkerScope() {
    [native code]
}, setScrollMarks:function setScrollMarks() {
    [native code]
}, get controllers() {
    [native code]
}, set controllers() {
    [native code]
}, get realFrameElement() {
    [native code]
}, get docShell() {
    [native code]
}, get browsingContext() {
    [native code]
}, get desktopToDeviceScale() {
    [native code]
}, get scrollMinX() {
    [native code]
}, get scrollMinY() {
    [native code]
}, get windowRoot() {
    [native code]
}, get windowUtils() {
    [native code]
}, get windowGlobalChild() {
    [native code]
}, get clientPrincipal() {
    [native code]
}, get isChromeWindow() {
    [native code]
}, get Glean() {
    [native code]
}, get GleanPings() {
    [native code]
}}, _options:{skipBreakpoints:false, pauseOnExceptions:false, ignoreCaughtExceptions:true, shouldShowOverlay:true, shouldIncludeSavedFrames:true, shouldIncludeAsyncLiveFrames:false, logEventBreakpoints:false, observeAsmJS:true}, _gripDepth:0, _parentClosed:false, _observingNetwork:false, _frameActors:[], _xhrBreakpoints:[], _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, _threadLifetimePool:null, _activeEventPause:null, _pauseOverlay:null, _priorPause:null, _activeEventBreakpoints:{}, _frameActorMap:{}, _debuggerSourcesSeen:{}, _onLoadBreakpointURLs:{}, _handledFrameExceptions:{}, _watchpointsMap:{threadActor:{}, _watchpoints:{}}, breakpointActorMap:{_threadActor:{}, _actors:{}}, _nestedEventLoop:{_thread:{}, _entered:false, _resolved:false}, onNewSourceEvent:function bound onNewSourceEvent() {
    [native code]
}, createCompletionGrip:function bound createCompletionGrip() {
    [native code]
}, onDebuggerStatement:function bound onDebuggerStatement() {
    [native code]
}, onNewScript:function bound onNewScript() {
    [native code]
}, objectGrip:function bound objectGrip() {
    [native code]
}, pauseObjectGrip:function bound pauseObjectGrip() {
    [native code]
}, _onOpeningRequest:function bound _onOpeningRequest() {
    [native code]
}, _onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}, _onExceptionUnwind:function bound _onExceptionUnwind() {
    [native code]
}, _eventBreakpointListener:function bound _eventBreakpointListener() {
    [native code]
}, _onWindowReady:function bound _onWindowReady() {
    [native code]
}, _onWillNavigate:function bound _onWillNavigate() {
    [native code]
}, _onNavigate:function bound _onNavigate() {
    [native code]
}, _firstStatementBreakpoint:null, _debuggerNotificationObserver:{}, parentPool:{}, alreadyAttached:true, wrappedJSObject:{}, _shouldEmitNewSource:false, _pendingResponse:{}, [Symbol("EventEmitter/listeners")]:{}}, __poolMap:{}, _progressListener:{_targetActor:{}, _onWindowCreated:function bound () {
    [native code]
}, _onWindowHidden:function bound () {
    [native code]
}, _knownWindowIDs:{}, _watchedDocShells:{}}, _docShellsObserved:true, parentPool:{}, createdFromJsWindowActor:true, _targetScopedActorPool:{conn:{_prefix:"server0.conn0.windowGlobal4294967303/", _transport:{hooks:{}, _jsWindowActor:{_connections:{}, on:function bound on() {
    [native code]
}, off:function bound off() {
    [native code]
}, once:function bound once() {
    [native code]
}, emit:function bound emit() {
    [native code]
}, get isBfcacheInParentEnabled() {
        if (!redefining) {
          // Make sure we don't get into an infinite recursion loop if
          // the getter lambda does something shady.
          redefining = true;
          return redefine(aObject, aName, aLambda.apply(aObject));
        }
        return undefined;
      }, useCustomLoader:false, loader:{DevToolsLoader:function DevToolsLoader({
  invisibleToDebugger = false,
  freshCompartment = false,
  useDevToolsLoaderGlobal = false,
} = {}) {
  if (useDevToolsLoaderGlobal && (invisibleToDebugger || freshCompartment)) {
    throw new Error(
      "Loader cannot use invisibleToDebugger or freshCompartment if useDevToolsLoaderGlobal is true"
    );
  }

  const paths = {
    // This resource:// URI is only registered when running DAMP tests.
    // This is done by: testing/talos/talos/tests/devtools/addon/api.js
    "damp-test": "resource://damp-test/content",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    devtools: "resource://devtools",
    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to xpcshell test items from the loader.
    "xpcshell-test": "resource://test",

    // ⚠ DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING ⚠
    // Allow access to locale data using paths closer to what is
    // used in the source tree.
    "devtools/client/locales": "chrome://devtools/locale",
    "devtools/shared/locales": "chrome://devtools-shared/locale",
    "devtools/startup/locales": "chrome://devtools-startup/locale",
    "toolkit/locales": "chrome://global/locale",
  };

  const sharedGlobal = useDevToolsLoaderGlobal
    ? Cu.getGlobalForObject({})
    : undefined;
  this.loader = new Loader({
    paths,
    sharedGlobal,
    invisibleToDebugger,
    freshCompartment,
    sandboxName: "DevTools (Module loader)",
    // Make sure `define` function exists. JSON Viewer needs modules in AMD
    // format, as it currently uses RequireJS from a content document and
    // can't access our usual loaders. So, any modules shared with the JSON
    // Viewer should include a define wrapper:
    //
    //   // Make this available to both AMD and CJS environments
    //   define(function(require, exports, module) {
    //     ... code ...
    //   });
    //
    // Bug 1248830 will work out a better plan here for our content module
    // loading needs, especially as we head towards devtools.html.
    supportAMDModules: true,
    requireHook: (id, require) => {
      if (id.startsWith("raw!") || id.startsWith("theme-loader!")) {
        return requireRawId(id, require);
      }
      return require(id);
    },
  });

  this.require = Require(this.loader, { id: "devtools" });

  // Various globals are available from ESM, but not from sandboxes,
  // inject them into the globals list.
  // Changes here should be mirrored to devtools/.eslintrc.
  const injectedGlobals = {
    CanonicalBrowsingContext,
    console,
    BrowsingContext,
    ChromeWorker,
    DebuggerNotificationObserver,
    DOMPoint,
    DOMQuad,
    DOMRect,
    HeapSnapshot,
    IOUtils,
    L10nRegistry,
    Localization,
    NamedNodeMap,
    NodeFilter,
    PathUtils,
    Services,
    StructuredCloneHolder,
    TelemetryStopwatch,
    WebExtensionPolicy,
    WindowGlobalParent,
    WindowGlobalChild,
  };
  for (const name in injectedGlobals) {
    this.loader.globals[name] = injectedGlobals[name];
  }

  // Fetch custom pseudo modules and globals
  const { modules, globals } = this.require(
    "resource://devtools/shared/loader/builtin-modules.js"
  );

  // Register custom pseudo modules to the current loader instance
  for (const id in modules) {
    const uri = resolveURI(id, this.loader.mapping);
    this.loader.modules[uri] = {
      get exports() {
        return modules[id];
      },
    };
  }

  // Register custom globals to the current loader instance
  Object.defineProperties(
    this.loader.sharedGlobal,
    Object.getOwnPropertyDescriptors(globals)
  );

  // Define the loader id for these two usecases:
  // * access via the JSM (this.id)
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.id
  this.id = gNextLoaderID++;
  // * access via module's `loader` global
  // loader.id
  globals.loader.id = this.id;
  globals.loader.invisibleToDebugger = invisibleToDebugger;

  // Expose lazy helpers on `loader`
  // ie. when you use it like that from a JSM:
  // let { loader } = ChromeUtils.importESModule("resource://devtools/shared/loader/Loader.sys.mjs");
  // loader.lazyGetter(...);
  this.lazyGetter = globals.loader.lazyGetter;
  this.lazyServiceGetter = globals.loader.lazyServiceGetter;
  this.lazyRequireGetter = globals.loader.lazyRequireGetter;
}, loader:{loader:{}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }, id:0, lazyGetter:function defineLazyGetter(object, name, lambda) {
  Object.defineProperty(object, name, {
    get() {
      // Redefine this accessor property as a data property.
      // Delete it first, to rule out "too much recursion" in case object is
      // a proxy whose defineProperty handler might unwittingly trigger this
      // getter again.
      delete object[name];
      const value = lambda.apply(object);
      Object.defineProperty(object, name, {
        value,
        writable: true,
        configurable: true,
        enumerable: true,
      });
      return value;
    },
    configurable: true,
    enumerable: true,
  });
}, lazyServiceGetter:function defineLazyServiceGetter(object, name, contract, interfaceName) {
  defineLazyGetter(object, name, function() {
    return Cc[contract].getService(Ci[interfaceName]);
  });
}, lazyRequireGetter:function lazyRequireGetter(obj, properties, module, destructure) {
  if (Array.isArray(properties) && !destructure) {
    throw new Error(
      "Pass destructure=true to call lazyRequireGetter with an array of properties"
    );
  }

  if (!Array.isArray(properties)) {
    properties = [properties];
  }

  for (const property of properties) {
    defineLazyGetter(obj, property, () => {
      return destructure
        ? require(module)[property]
        : require(module || property);
    });
  }
}}, require:function require(id) {
    if (!id) {
      // Throw if `id` is not passed.
      throw Error(
        "You must provide a module name when calling require() from " +
          requirer.id,
        requirer.uri
      );
    }

    if (requireHook) {
      return requireHook(id, _require);
    }

    return _require(id);
  }}}, _prefix:"server0.conn0.windowGlobal4294967303", _onPacketReceived:function bound _onPacketReceived() {
    [native code]
}}, _nextID:20, _socketListener:null, _actorPool:null, _extraPools:[{__poolMap:null, parentPool:null, conn:{}, label:"server-connection", _isDestroyed:false}, {}, {}], _actorResponses:{}, _forwardingPrefixes:{}, currentPacket:(void 0)}, __poolMap:{}}, _dbg:{addDebuggees:(function() {
    for (const global of findDebuggees(this)) {
      safeAddDebuggee(this, global);
    }
  }), disable:(function() {
    dbg.removeAllDebuggees();
    dbg.onNewGlobalObject = undefined;
  }), enable:(function() {
    dbg.addDebuggees();
    dbg.onNewGlobalObject = onNewGlobalObject;
  }), onNewDebuggee:function bound _onNewDebuggee() {
    [native code]
}}, customFormatters:false, _styleSheetManager:{_styleSheetCount:0, _styleSheetMap:{}, _mqlList:[], _targetActor:{}, _onApplicableStateChanged:function bound _onApplicableStateChanged() {
    [native code]
}, _onTargetActorWindowReady:function bound _onTargetActorWindowReady() {
    [native code]
}, [Symbol("EventEmitter/listeners")]:{}}, [Symbol("EventEmitter/listeners")]:{}}) ": " (new TypeError("this._targetActor.chromeEventHandler is null", "resource://devtools/server/actors/utils/stylesheets-manager.js", 915))
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 1712: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/connectors/js-window-actor/DevToolsFrameChild.sys.mjs, line 376: InvalidStateError: JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment
console.warn: "Listener for event 'frame' did not return a promise."
JavaScript error: resource://devtools/server/actors/utils/stylesheets-manager.js, line 838: TypeError: this._targetActor is null
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://demo.nopcommerce.com."
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 422: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/utils/stylesheets-manager.js, line 838: TypeError: this._targetActor is null
console.error: "Unable to find target with innerWindowId:4294967301"
console.error: "Unable to find target with innerWindowId:4294967301"
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 469: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://devtools/server/actors/utils/stylesheets-manager.js, line 838: TypeError: this._targetActor is null
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://demo.nopcommerce.com."
JavaScript error: , line 0: NS_ERROR_NOT_AVAILABLE
JavaScript error: resource://devtools/server/actors/targets/window-global.js, line 422: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsIDocShell.domWindow]
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 560: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 560: NotFoundError: No such JSWindowActor 'DevToolsFrame'
1672069276917	Marionette	INFO	Stopped listening on port 63077
821765	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofileSE32Fz\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:63463/devtools/browser/801346ab-c566-41df-a2b3-76fdf1c7290d
JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
JavaScript error: , line 0: NS_ERROR_NOT_AVAILABLE
1672069274951	Marionette	INFO	Stopped listening on port 63475
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
" "localhost" "-no-remote" "-profile" "C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofilejYagnZ"
1672068274291	Marionette	INFO	Marionette enabled
1672068274303	Marionette	INFO	Listening on port 63736
Read port: 63736
WebDriver BiDi listening on ws://127.0.0.1:63725
1672068274627	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofilejYagnZ\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:63725/devtools/browser/621973b0-c070-4e67-8bc9-c6a79067d617
JavaScript error: , line 0: NS_ERROR_NOT_AVAILABLE
1672069277920	Marionette	INFO	Stopped listening on port 63736
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
!!! error running onStopped callback: TypeError: callback is not a function
mp\\rust_mozprofilefrS0hU"
1672068312394	Marionette	INFO	Marionette enabled
1672068312408	Marionette	INFO	Listening on port 63795
Read port: 63795
WebDriver BiDi listening on ws://127.0.0.1:63784
1672068312742	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofilefrS0hU\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:63784/devtools/browser/50d19837-c7cc-4b91-b786-a7ac4bf0888c
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://demo.nopcommerce.com."
JavaScript error: , line 0: NS_ERROR_NOT_AVAILABLE
1672069278960	Marionette	INFO	Stopped listening on port 63795
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
!!! error running onStopped callback: TypeError: callback is not a function
mp\\rust_mozprofileTIfr0h"
1672068957388	Marionette	INFO	Marionette enabled
1672068957396	Marionette	INFO	Listening on port 64186
Read port: 64186
WebDriver BiDi listening on ws://127.0.0.1:64175
1672068957713	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofileTIfr0h\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:64175/devtools/browser/d61760b8-8a84-4a1e-ab15-5b277a873095
JavaScript warning: https://static.xx.fbcdn.net/rsrc.php/v3iX3c4/ye/l/en_GB/LHUxA4o6J25.js?_nc_x=Ij3Wp8lg5Kz, line 21: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
1672068976314	Marionette	INFO	Stopped listening on port 64186
WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
sendPing@resource://gre/modules/EventPing.jsm:51:30
_submitPing@resource://gre/modules/EventPing.jsm:229:12
shutdown@resource://gre/modules/EventPing.jsm:112:10
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:940:31
shutdown/<@resource://gre/modules/TelemetryControllerParent.jsm:1010:24
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:982:34
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:1014:36
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  TelemetryController: shutting down
          Phase: profile-before-change-telemetry
          State: Error getting state: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange" at addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
getShutdownState@resource://gre/modules/TelemetrySend.jsm:1687:7
getShutdownState@resource://gre/modules/TelemetrySend.jsm:369:30
_getState@resource://gre/modules/TelemetryControllerParent.jsm:1058:38
setupTelemetry/<@resource://gre/modules/TelemetryControllerParent.jsm:917:18
safeGetState@resource://gre/modules/AsyncShutdown.jsm:242:17
Barrier/addBlocker/promise<@resource://gre/modules/AsyncShutdown.jsm:751:20
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:721:5
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:249:17
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1235:42
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
1672068985765	geckodriver	INFO	Listening on 127.0.0.1:64240
1672068988752	mozrunner::runner	INFO	Running command: "C:\\Program Files\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "64241" "--remote-allow-hosts" "localhost" "-no-remote" "-profile" "C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofilelxT52v"
1672068990194	Marionette	INFO	Marionette enabled
1672068990205	Marionette	INFO	Listening on port 64252
Read port: 64252
WebDriver BiDi listening on ws://127.0.0.1:64241
1672068990899	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofilelxT52v\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:64241/devtools/browser/7c5368e5-5222-47bf-b4c2-ad846a3cfc54
JavaScript warning: https://static.xx.fbcdn.net/rsrc.php/v3iX3c4/ye/l/en_GB/LHUxA4o6J25.js?_nc_x=Ij3Wp8lg5Kz, line 21: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://www.facebook.com."
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://www.facebook.com."
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://www.facebook.com."
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://www.facebook.com."
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://www.facebook.com."
JavaScript error: , line 0: NotFoundError: No such JSWindowActor 'DevToolsFrame'
1672069280607	Marionette	INFO	Stopped listening on port 64252
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
!!! error running onStopped callback: TypeError: callback is not a function
1672116249127	geckodriver	INFO	Listening on 127.0.0.1:65140
1672116252110	mozrunner::runner	INFO	Running command: "C:\\Program Files\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "65141" "--remote-allow-hosts" "localhost" "-no-remote" "-profile" "C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofileftaNJu"
1672116256187	Marionette	INFO	Marionette enabled
1672116256212	Marionette	INFO	Listening on port 65150
Read port: 65150
WebDriver BiDi listening on ws://127.0.0.1:65141
1672116256698	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofileftaNJu\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:65141/devtools/browser/d5a6bdf0-e07f-4001-a8aa-dc19f2119bae
JavaScript warning: https://static.xx.fbcdn.net/rsrc.php/v3iX3c4/ye/l/en_GB/LHUxA4o6J25.js?_nc_x=Ij3Wp8lg5Kz, line 21: WEBGL_debug_renderer_info is deprecated in Firefox and will be removed. Please use RENDERER.
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://www.facebook.com."
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://www.facebook.com."
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://www.facebook.com."
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://www.facebook.com."
1672116278564	Marionette	INFO	Stopped listening on port 65150
WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
sendPing@resource://gre/modules/EventPing.jsm:51:30
_submitPing@resource://gre/modules/EventPing.jsm:229:12
shutdown@resource://gre/modules/EventPing.jsm:112:10
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:940:31
shutdown/<@resource://gre/modules/TelemetryControllerParent.jsm:1010:24
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:982:34
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:1014:36
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  TelemetryController: shutting down
          Phase: profile-before-change-telemetry
          State: Error getting state: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange" at addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
getShutdownState@resource://gre/modules/TelemetrySend.jsm:1687:7
getShutdownState@resource://gre/modules/TelemetrySend.jsm:369:30
_getState@resource://gre/modules/TelemetryControllerParent.jsm:1058:38
setupTelemetry/<@resource://gre/modules/TelemetryControllerParent.jsm:917:18
safeGetState@resource://gre/modules/AsyncShutdown.jsm:242:17
Barrier/addBlocker/promise<@resource://gre/modules/AsyncShutdown.jsm:751:20
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:721:5
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:249:17
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1235:42
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
1672116343117	geckodriver	INFO	Listening on 127.0.0.1:65198
1672116346144	mozrunner::runner	INFO	Running command: "C:\\Program Files\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "65199" "--remote-allow-hosts" "localhost" "-no-remote" "-profile" "C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofilerqdYxv"
1672116346989	Marionette	INFO	Marionette enabled
1672116346998	Marionette	INFO	Listening on port 65208
Read port: 65208
WebDriver BiDi listening on ws://127.0.0.1:65199
1672116347221	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofilerqdYxv\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:65199/devtools/browser/60076196-2a0e-4cf1-9f47-0df6df950725
console.warn: LoginRecipes: "Falling back to a synchronous message for: https://demo.nopcommerce.com."
1672125456897	Marionette	INFO	Stopped listening on port 65208
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
1672130483338	geckodriver	INFO	Listening on 127.0.0.1:51344
1672130486374	mozrunner::runner	INFO	Running command: "C:\\Program Files\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "51345" "--remote-allow-hosts" "localhost" "-no-remote" "-profile" "C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofile0JD0LC"
1672130486985	Marionette	INFO	Marionette enabled
1672130486996	Marionette	INFO	Listening on port 51354
Read port: 51354
WebDriver BiDi listening on ws://127.0.0.1:51345
1672130487210	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofile0JD0LC\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:51345/devtools/browser/4c3400cd-015c-45ed-b304-6a80f0be8a59
1672130499645	Marionette	INFO	Stopped listening on port 51354
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
sendPing@resource://gre/modules/EventPing.jsm:51:30
_submitPing@resource://gre/modules/EventPing.jsm:229:12
shutdown@resource://gre/modules/EventPing.jsm:112:10
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:940:31
shutdown/<@resource://gre/modules/TelemetryControllerParent.jsm:1010:24
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:982:34
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:1014:36
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  TelemetryController: shutting down
          Phase: profile-before-change-telemetry
          State: Error getting state: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange" at addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
getShutdownState@resource://gre/modules/TelemetrySend.jsm:1687:7
getShutdownState@resource://gre/modules/TelemetrySend.jsm:369:30
_getState@resource://gre/modules/TelemetryControllerParent.jsm:1058:38
setupTelemetry/<@resource://gre/modules/TelemetryControllerParent.jsm:917:18
safeGetState@resource://gre/modules/AsyncShutdown.jsm:242:17
Barrier/addBlocker/promise<@resource://gre/modules/AsyncShutdown.jsm:751:20
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:721:5
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:249:17
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1235:42
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
1672130678463	geckodriver	INFO	Listening on 127.0.0.1:51475
1672130681487	mozrunner::runner	INFO	Running command: "C:\\Program Files\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "51476" "--remote-allow-hosts" "localhost" "-no-remote" "-profile" "C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofileUZ66u1"
1672130682075	Marionette	INFO	Marionette enabled
1672130682087	Marionette	INFO	Listening on port 51487
Read port: 51487
WebDriver BiDi listening on ws://127.0.0.1:51476
1672130682293	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofileUZ66u1\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:51476/devtools/browser/eedfb9d4-65cb-4b0b-ba50-76517b9394aa
1672130703562	Marionette	INFO	Stopped listening on port 51487
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
sendPing@resource://gre/modules/EventPing.jsm:51:30
_submitPing@resource://gre/modules/EventPing.jsm:229:12
shutdown@resource://gre/modules/EventPing.jsm:112:10
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:940:31
shutdown/<@resource://gre/modules/TelemetryControllerParent.jsm:1010:24
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:982:34
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:1014:36
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  TelemetryController: shutting down
          Phase: profile-before-change-telemetry
          State: Error getting state: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange" at addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
getShutdownState@resource://gre/modules/TelemetrySend.jsm:1687:7
getShutdownState@resource://gre/modules/TelemetrySend.jsm:369:30
_getState@resource://gre/modules/TelemetryControllerParent.jsm:1058:38
setupTelemetry/<@resource://gre/modules/TelemetryControllerParent.jsm:917:18
safeGetState@resource://gre/modules/AsyncShutdown.jsm:242:17
Barrier/addBlocker/promise<@resource://gre/modules/AsyncShutdown.jsm:751:20
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:721:5
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:249:17
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1235:42
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
1672131215389	geckodriver	INFO	Listening on 127.0.0.1:51774
1672131218426	mozrunner::runner	INFO	Running command: "C:\\Program Files\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "51775" "--remote-allow-hosts" "localhost" "-no-remote" "-profile" "C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofile07hUcP"
1672131219119	Marionette	INFO	Marionette enabled
1672131219131	Marionette	INFO	Listening on port 51785
Read port: 51785
WebDriver BiDi listening on ws://127.0.0.1:51775
1672131219336	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofile07hUcP\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:51775/devtools/browser/bbd13e28-956a-485e-95d4-6d51b28962b3
1672131231025	Marionette	INFO	Stopped listening on port 51785
JavaScript error: resource://gre/modules/UrlClassifierListManager.jsm, line 693: TypeError: this.tablesData[table] is undefined
JavaScript error: chrome://remote/content/marionette/cert.sys.mjs, line 51: NS_ERROR_NOT_AVAILABLE: Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsICertOverrideService.setDisableAllSecurityChecksAndLetAttackersInterceptMyData]
!!! error running onStopped callback: TypeError: callback is not a function
1672131231131	RemoteAgent	ERROR	unable to stop listener: [Exception... "Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE) [nsICertOverrideService.setDisableAllSecurityChecksAndLetAttackersInterceptMyData]"  nsresult: "0x80040111 (NS_ERROR_NOT_AVAILABLE)"  location: "JS frame :: chrome://remote/content/marionette/cert.sys.mjs :: allowAllCerts.disable :: line 51"  data: no] Stack trace: allowAllCerts.disable()@sys.mjs:51
destroy()@sys.mjs:201
deleteSession()@sys.mjs:142
stop()@sys.mjs:221
WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
sendPing@resource://gre/modules/EventPing.jsm:51:30
_submitPing@resource://gre/modules/EventPing.jsm:229:12
shutdown@resource://gre/modules/EventPing.jsm:112:10
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:940:31
shutdown/<@resource://gre/modules/TelemetryControllerParent.jsm:1010:24
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:982:34
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:1014:36
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  TelemetryController: shutting down
          Phase: profile-before-change-telemetry
          State: Error getting state: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange" at addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
getShutdownState@resource://gre/modules/TelemetrySend.jsm:1687:7
getShutdownState@resource://gre/modules/TelemetrySend.jsm:369:30
_getState@resource://gre/modules/TelemetryControllerParent.jsm:1058:38
setupTelemetry/<@resource://gre/modules/TelemetryControllerParent.jsm:917:18
safeGetState@resource://gre/modules/AsyncShutdown.jsm:242:17
Barrier/addBlocker/promise<@resource://gre/modules/AsyncShutdown.jsm:751:20
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:721:5
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:249:17
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1235:42
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
1672131455778	geckodriver	INFO	Listening on 127.0.0.1:51927
1672131458812	mozrunner::runner	INFO	Running command: "C:\\Program Files\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "51928" "--remote-allow-hosts" "localhost" "-no-remote" "-profile" "C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofileW98ewx"
1672131459592	Marionette	INFO	Marionette enabled
1672131459603	Marionette	INFO	Listening on port 51939
Read port: 51939
WebDriver BiDi listening on ws://127.0.0.1:51928
1672131459825	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofileW98ewx\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:51928/devtools/browser/9cb773f9-851e-4610-9ac2-87760e34bb56
1672131470718	Marionette	INFO	Stopped listening on port 51939
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
JavaScript error: resource://gre/modules/UrlClassifierListManager.jsm, line 693: TypeError: this.tablesData[table] is undefined
WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
sendPing@resource://gre/modules/EventPing.jsm:51:30
_submitPing@resource://gre/modules/EventPing.jsm:229:12
shutdown@resource://gre/modules/EventPing.jsm:112:10
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:940:31
shutdown/<@resource://gre/modules/TelemetryControllerParent.jsm:1010:24
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:982:34
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:1014:36
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  TelemetryController: shutting down
          Phase: profile-before-change-telemetry
          State: Error getting state: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange" at addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
getShutdownState@resource://gre/modules/TelemetrySend.jsm:1687:7
getShutdownState@resource://gre/modules/TelemetrySend.jsm:369:30
_getState@resource://gre/modules/TelemetryControllerParent.jsm:1058:38
setupTelemetry/<@resource://gre/modules/TelemetryControllerParent.jsm:917:18
safeGetState@resource://gre/modules/AsyncShutdown.jsm:242:17
Barrier/addBlocker/promise<@resource://gre/modules/AsyncShutdown.jsm:751:20
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:721:5
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:249:17
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1235:42
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
1672131679395	geckodriver	INFO	Listening on 127.0.0.1:52076
1672131682435	mozrunner::runner	INFO	Running command: "C:\\Program Files\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "52077" "--remote-allow-hosts" "localhost" "-no-remote" "-profile" "C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofile0CJaJH"
1672131683259	Marionette	INFO	Marionette enabled
1672131683272	Marionette	INFO	Listening on port 52087
Read port: 52087
WebDriver BiDi listening on ws://127.0.0.1:52077
1672131683487	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofile0CJaJH\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:52077/devtools/browser/b4d3eb91-86d2-4863-a06a-7899018ea53b
1672131696853	Marionette	INFO	Stopped listening on port 52087
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
JavaScript error: resource://gre/modules/UrlClassifierListManager.jsm, line 693: TypeError: this.tablesData[table] is undefined
WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
sendPing@resource://gre/modules/EventPing.jsm:51:30
_submitPing@resource://gre/modules/EventPing.jsm:229:12
shutdown@resource://gre/modules/EventPing.jsm:112:10
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:940:31
shutdown/<@resource://gre/modules/TelemetryControllerParent.jsm:1010:24
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:982:34
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:1014:36
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  TelemetryController: shutting down
          Phase: profile-before-change-telemetry
          State: Error getting state: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange" at addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
getShutdownState@resource://gre/modules/TelemetrySend.jsm:1687:7
getShutdownState@resource://gre/modules/TelemetrySend.jsm:369:30
_getState@resource://gre/modules/TelemetryControllerParent.jsm:1058:38
setupTelemetry/<@resource://gre/modules/TelemetryControllerParent.jsm:917:18
safeGetState@resource://gre/modules/AsyncShutdown.jsm:242:17
Barrier/addBlocker/promise<@resource://gre/modules/AsyncShutdown.jsm:751:20
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:721:5
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:249:17
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1235:42
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
1672131971194	geckodriver	INFO	Listening on 127.0.0.1:52257
1672131974236	mozrunner::runner	INFO	Running command: "C:\\Program Files\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "52258" "--remote-allow-hosts" "localhost" "-no-remote" "-profile" "C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofile5WVHM6"
1672131974938	Marionette	INFO	Marionette enabled
1672131974948	Marionette	INFO	Listening on port 52269
Read port: 52269
WebDriver BiDi listening on ws://127.0.0.1:52258
1672131975185	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofile5WVHM6\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:52258/devtools/browser/32d67f83-80a5-4f13-a1d8-4bc273bf3c17
1672131986137	Marionette	INFO	Stopped listening on port 52269
JavaScript error: resource://gre/modules/UrlClassifierListManager.jsm, line 693: TypeError: this.tablesData[table] is undefined
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
sendPing@resource://gre/modules/EventPing.jsm:51:30
_submitPing@resource://gre/modules/EventPing.jsm:229:12
shutdown@resource://gre/modules/EventPing.jsm:112:10
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:940:31
shutdown/<@resource://gre/modules/TelemetryControllerParent.jsm:1010:24
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:982:34
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:1014:36
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  TelemetryController: shutting down
          Phase: profile-before-change-telemetry
          State: Error getting state: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange" at addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
getShutdownState@resource://gre/modules/TelemetrySend.jsm:1687:7
getShutdownState@resource://gre/modules/TelemetrySend.jsm:369:30
_getState@resource://gre/modules/TelemetryControllerParent.jsm:1058:38
setupTelemetry/<@resource://gre/modules/TelemetryControllerParent.jsm:917:18
safeGetState@resource://gre/modules/AsyncShutdown.jsm:242:17
Barrier/addBlocker/promise<@resource://gre/modules/AsyncShutdown.jsm:751:20
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:721:5
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:249:17
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1235:42
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
1672132623288	geckodriver	INFO	Listening on 127.0.0.1:52595
1672132626094	mozrunner::runner	INFO	Running command: "C:\\Program Files\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "52596" "--remote-allow-hosts" "localhost" "-no-remote" "-profile" "C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofileGuVIjQ"
1672132626728	Marionette	INFO	Marionette enabled
1672132626736	Marionette	INFO	Listening on port 52607
Read port: 52607
WebDriver BiDi listening on ws://127.0.0.1:52596
1672132626960	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofileGuVIjQ\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:52596/devtools/browser/34927c88-9407-4677-924b-e6fe8a17406d
1672132635687	Marionette	INFO	Stopped listening on port 52607
WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
sendPing@resource://gre/modules/EventPing.jsm:51:30
_submitPing@resource://gre/modules/EventPing.jsm:229:12
shutdown@resource://gre/modules/EventPing.jsm:112:10
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:940:31
shutdown/<@resource://gre/modules/TelemetryControllerParent.jsm:1010:24
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:982:34
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:1014:36
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  TelemetryController: shutting down
          Phase: profile-before-change-telemetry
          State: Error getting state: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange" at addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
getShutdownState@resource://gre/modules/TelemetrySend.jsm:1687:7
getShutdownState@resource://gre/modules/TelemetrySend.jsm:369:30
_getState@resource://gre/modules/TelemetryControllerParent.jsm:1058:38
setupTelemetry/<@resource://gre/modules/TelemetryControllerParent.jsm:917:18
safeGetState@resource://gre/modules/AsyncShutdown.jsm:242:17
Barrier/addBlocker/promise<@resource://gre/modules/AsyncShutdown.jsm:751:20
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:721:5
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:249:17
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1235:42
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
1672132832282	geckodriver	INFO	Listening on 127.0.0.1:52735
1672132835287	mozrunner::runner	INFO	Running command: "C:\\Program Files\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "52736" "--remote-allow-hosts" "localhost" "-no-remote" "-profile" "C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofile4uGq1L"
1672132835925	Marionette	INFO	Marionette enabled
1672132835938	Marionette	INFO	Listening on port 52747
Read port: 52747
WebDriver BiDi listening on ws://127.0.0.1:52736
1672132836181	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofile4uGq1L\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:52736/devtools/browser/28e6ba23-85a7-4349-b980-b2ec9b0a11f7
1672132844975	Marionette	INFO	Stopped listening on port 52747
WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
sendPing@resource://gre/modules/EventPing.jsm:51:30
_submitPing@resource://gre/modules/EventPing.jsm:229:12
shutdown@resource://gre/modules/EventPing.jsm:112:10
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:940:31
shutdown/<@resource://gre/modules/TelemetryControllerParent.jsm:1010:24
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:982:34
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:1014:36
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  TelemetryController: shutting down
          Phase: profile-before-change-telemetry
          State: Error getting state: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange" at addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
getShutdownState@resource://gre/modules/TelemetrySend.jsm:1687:7
getShutdownState@resource://gre/modules/TelemetrySend.jsm:369:30
_getState@resource://gre/modules/TelemetryControllerParent.jsm:1058:38
setupTelemetry/<@resource://gre/modules/TelemetryControllerParent.jsm:917:18
safeGetState@resource://gre/modules/AsyncShutdown.jsm:242:17
Barrier/addBlocker/promise<@resource://gre/modules/AsyncShutdown.jsm:751:20
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:721:5
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:249:17
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1235:42
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
1672137209028	geckodriver	INFO	Listening on 127.0.0.1:55220
1672137212088	mozrunner::runner	INFO	Running command: "C:\\Program Files\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "55221" "--remote-allow-hosts" "localhost" "-no-remote" "-profile" "C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofileUOhxkb"
1672137212813	Marionette	INFO	Marionette enabled
1672137212823	Marionette	INFO	Listening on port 55231
Read port: 55231
WebDriver BiDi listening on ws://127.0.0.1:55221
1672137213092	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
1672137224173	geckodriver	INFO	Listening on 127.0.0.1:55244
1672137227193	mozrunner::runner	INFO	Running command: "C:\\Program Files\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "55245" "--remote-allow-hosts" "localhost" "-no-remote" "-profile" "C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofilehZmqD7"
1672137227849	Marionette	INFO	Marionette enabled
1672137227858	Marionette	INFO	Listening on port 55256
WebDriver BiDi listening on ws://127.0.0.1:55245
Read port: 55256
1672137229775	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofilehZmqD7\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:55245/devtools/browser/bae43ec3-5dc1-44d3-9805-88d2d0a99aba
1672137237589	Marionette	INFO	Stopped listening on port 55256
WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
sendPing@resource://gre/modules/EventPing.jsm:51:30
_submitPing@resource://gre/modules/EventPing.jsm:229:12
shutdown@resource://gre/modules/EventPing.jsm:112:10
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:940:31
shutdown/<@resource://gre/modules/TelemetryControllerParent.jsm:1010:24
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:982:34
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:1014:36
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  TelemetryController: shutting down
          Phase: profile-before-change-telemetry
          State: Error getting state: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange" at addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
getShutdownState@resource://gre/modules/TelemetrySend.jsm:1687:7
getShutdownState@resource://gre/modules/TelemetrySend.jsm:369:30
_getState@resource://gre/modules/TelemetryControllerParent.jsm:1058:38
setupTelemetry/<@resource://gre/modules/TelemetryControllerParent.jsm:917:18
safeGetState@resource://gre/modules/AsyncShutdown.jsm:242:17
Barrier/addBlocker/promise<@resource://gre/modules/AsyncShutdown.jsm:751:20
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:721:5
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:249:17
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1235:42
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
1672137282887	geckodriver	INFO	Listening on 127.0.0.1:55313
1672137285902	mozrunner::runner	INFO	Running command: "C:\\Program Files\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "55314" "--remote-allow-hosts" "localhost" "-no-remote" "-profile" "C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofile4oOWkn"
1672137286515	Marionette	INFO	Marionette enabled
1672137286526	Marionette	INFO	Listening on port 55325
Read port: 55325
WebDriver BiDi listening on ws://127.0.0.1:55314
1672137286763	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofile4oOWkn\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:55314/devtools/browser/e51665e5-3e61-4099-851c-1e8984866a92
1672137295065	Marionette	INFO	Stopped listening on port 55325
WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
sendPing@resource://gre/modules/EventPing.jsm:51:30
_submitPing@resource://gre/modules/EventPing.jsm:229:12
shutdown@resource://gre/modules/EventPing.jsm:112:10
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:940:31
shutdown/<@resource://gre/modules/TelemetryControllerParent.jsm:1010:24
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:982:34
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:1014:36
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  TelemetryController: shutting down
          Phase: profile-before-change-telemetry
          State: Error getting state: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange" at addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
getShutdownState@resource://gre/modules/TelemetrySend.jsm:1687:7
getShutdownState@resource://gre/modules/TelemetrySend.jsm:369:30
_getState@resource://gre/modules/TelemetryControllerParent.jsm:1058:38
setupTelemetry/<@resource://gre/modules/TelemetryControllerParent.jsm:917:18
safeGetState@resource://gre/modules/AsyncShutdown.jsm:242:17
Barrier/addBlocker/promise<@resource://gre/modules/AsyncShutdown.jsm:751:20
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:721:5
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:249:17
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1235:42
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
1672137410878	geckodriver	INFO	Listening on 127.0.0.1:55416
1672137413904	mozrunner::runner	INFO	Running command: "C:\\Program Files\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "55417" "--remote-allow-hosts" "localhost" "-no-remote" "-profile" "C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofiledAu6w9"
1672137414502	Marionette	INFO	Marionette enabled
1672137414514	Marionette	INFO	Listening on port 55428
Read port: 55428
WebDriver BiDi listening on ws://127.0.0.1:55417
1672137414737	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofiledAu6w9\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:55417/devtools/browser/c3fb03f0-5f4b-4193-bc6e-7afa5887e848
1672137423745	Marionette	INFO	Stopped listening on port 55428
WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
sendPing@resource://gre/modules/EventPing.jsm:51:30
_submitPing@resource://gre/modules/EventPing.jsm:229:12
shutdown@resource://gre/modules/EventPing.jsm:112:10
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:940:31
shutdown/<@resource://gre/modules/TelemetryControllerParent.jsm:1010:24
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:982:34
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:1014:36
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  TelemetryController: shutting down
          Phase: profile-before-change-telemetry
          State: Error getting state: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange" at addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
getShutdownState@resource://gre/modules/TelemetrySend.jsm:1687:7
getShutdownState@resource://gre/modules/TelemetrySend.jsm:369:30
_getState@resource://gre/modules/TelemetryControllerParent.jsm:1058:38
setupTelemetry/<@resource://gre/modules/TelemetryControllerParent.jsm:917:18
safeGetState@resource://gre/modules/AsyncShutdown.jsm:242:17
Barrier/addBlocker/promise<@resource://gre/modules/AsyncShutdown.jsm:751:20
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:721:5
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:249:17
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1235:42
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
1672137455185	geckodriver	INFO	Listening on 127.0.0.1:55479
1672137458198	mozrunner::runner	INFO	Running command: "C:\\Program Files\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "55480" "--remote-allow-hosts" "localhost" "-no-remote" "-profile" "C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofileXuzA1y"
1672137458810	Marionette	INFO	Marionette enabled
1672137458824	Marionette	INFO	Listening on port 55490
Read port: 55490
WebDriver BiDi listening on ws://127.0.0.1:55480
1672137459098	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofileXuzA1y\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:55480/devtools/browser/3a3ea028-d4bc-477c-a3e3-5ad88f6f5324
1672137671982	Marionette	INFO	Stopped listening on port 55490
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
1672137761284	geckodriver	INFO	Listening on 127.0.0.1:55668
1672137764325	mozrunner::runner	INFO	Running command: "C:\\Program Files\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "55669" "--remote-allow-hosts" "localhost" "-no-remote" "-profile" "C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofileD545sY"
1672137765025	Marionette	INFO	Marionette enabled
1672137765036	Marionette	INFO	Listening on port 55679
Read port: 55679
WebDriver BiDi listening on ws://127.0.0.1:55669
1672137765262	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofileD545sY\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:55669/devtools/browser/674cb2fe-092a-4d0f-9f82-f43b625a17c3
1672137779025	Marionette	INFO	Stopped listening on port 55679
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
sendPing@resource://gre/modules/EventPing.jsm:51:30
_submitPing@resource://gre/modules/EventPing.jsm:229:12
shutdown@resource://gre/modules/EventPing.jsm:112:10
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:940:31
shutdown/<@resource://gre/modules/TelemetryControllerParent.jsm:1010:24
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:982:34
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:1014:36
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  TelemetryController: shutting down
          Phase: profile-before-change-telemetry
          State: Error getting state: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange" at addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
getShutdownState@resource://gre/modules/TelemetrySend.jsm:1687:7
getShutdownState@resource://gre/modules/TelemetrySend.jsm:369:30
_getState@resource://gre/modules/TelemetryControllerParent.jsm:1058:38
setupTelemetry/<@resource://gre/modules/TelemetryControllerParent.jsm:917:18
safeGetState@resource://gre/modules/AsyncShutdown.jsm:242:17
Barrier/addBlocker/promise<@resource://gre/modules/AsyncShutdown.jsm:751:20
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:721:5
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:249:17
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1235:42
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
1672137822160	geckodriver	INFO	Listening on 127.0.0.1:55745
1672137825183	mozrunner::runner	INFO	Running command: "C:\\Program Files\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "55746" "--remote-allow-hosts" "localhost" "-no-remote" "-profile" "C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofileSKFZu0"
1672137825831	Marionette	INFO	Marionette enabled
1672137825845	Marionette	INFO	Listening on port 55756
Read port: 55756
WebDriver BiDi listening on ws://127.0.0.1:55746
1672137826068	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofileSKFZu0\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:55746/devtools/browser/b2749785-259c-4318-a6e3-5501a642469a
JavaScript error: resource://gre/actors/ContentMetaChild.jsm, line 183: InvalidStateError: JSWindowActorChild.sendAsyncMessage: JSWindowActorChild cannot send at the moment
1672137848555	Marionette	INFO	Stopped listening on port 55756
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
sendPing@resource://gre/modules/EventPing.jsm:51:30
_submitPing@resource://gre/modules/EventPing.jsm:229:12
shutdown@resource://gre/modules/EventPing.jsm:112:10
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:940:31
shutdown/<@resource://gre/modules/TelemetryControllerParent.jsm:1010:24
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:982:34
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:1014:36
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  TelemetryController: shutting down
          Phase: profile-before-change-telemetry
          State: Error getting state: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange" at addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
getShutdownState@resource://gre/modules/TelemetrySend.jsm:1687:7
getShutdownState@resource://gre/modules/TelemetrySend.jsm:369:30
_getState@resource://gre/modules/TelemetryControllerParent.jsm:1058:38
setupTelemetry/<@resource://gre/modules/TelemetryControllerParent.jsm:917:18
safeGetState@resource://gre/modules/AsyncShutdown.jsm:242:17
Barrier/addBlocker/promise<@resource://gre/modules/AsyncShutdown.jsm:751:20
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:721:5
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:249:17
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1235:42
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
1672138020392	geckodriver	INFO	Listening on 127.0.0.1:55914
1672138023407	mozrunner::runner	INFO	Running command: "C:\\Program Files\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "55915" "--remote-allow-hosts" "localhost" "-no-remote" "-profile" "C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofileA0XLEb"
1672138024067	Marionette	INFO	Marionette enabled
1672138024078	Marionette	INFO	Listening on port 55926
Read port: 55926
WebDriver BiDi listening on ws://127.0.0.1:55915
1672138024312	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofileA0XLEb\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:55915/devtools/browser/8f98fe12-0601-481c-8414-fff7019d3b40
1672138048751	geckodriver	INFO	Listening on 127.0.0.1:55957
1672138051764	mozrunner::runner	INFO	Running command: "C:\\Program Files\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "55958" "--remote-allow-hosts" "localhost" "-no-remote" "-profile" "C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofileEx8rzg"
1672138052438	Marionette	INFO	Marionette enabled
1672138052447	Marionette	INFO	Listening on port 55969
Read port: 55969
WebDriver BiDi listening on ws://127.0.0.1:55958
1672138052668	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofileEx8rzg\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:55958/devtools/browser/d148f377-c6f8-49a9-8743-bef11415b5da
1672138065084	Marionette	INFO	Stopped listening on port 55969
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
sendPing@resource://gre/modules/EventPing.jsm:51:30
_submitPing@resource://gre/modules/EventPing.jsm:229:12
shutdown@resource://gre/modules/EventPing.jsm:112:10
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:940:31
shutdown/<@resource://gre/modules/TelemetryControllerParent.jsm:1010:24
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:982:34
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:1014:36
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  TelemetryController: shutting down
          Phase: profile-before-change-telemetry
          State: Error getting state: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange" at addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
getShutdownState@resource://gre/modules/TelemetrySend.jsm:1687:7
getShutdownState@resource://gre/modules/TelemetrySend.jsm:369:30
_getState@resource://gre/modules/TelemetryControllerParent.jsm:1058:38
setupTelemetry/<@resource://gre/modules/TelemetryControllerParent.jsm:917:18
safeGetState@resource://gre/modules/AsyncShutdown.jsm:242:17
Barrier/addBlocker/promise<@resource://gre/modules/AsyncShutdown.jsm:751:20
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:721:5
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:249:17
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1235:42
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
1672138094801	geckodriver	INFO	Listening on 127.0.0.1:56026
1672138097826	mozrunner::runner	INFO	Running command: "C:\\Program Files\\Mozilla Firefox\\firefox.exe" "--marionette" "--remote-debugging-port" "56027" "--remote-allow-hosts" "localhost" "-no-remote" "-profile" "C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofilem8DR7S"
1672138098464	Marionette	INFO	Marionette enabled
1672138098478	Marionette	INFO	Listening on port 56038
Read port: 56038
WebDriver BiDi listening on ws://127.0.0.1:56027
1672138098704	RemoteAgent	WARN	TLS certificate errors will be ignored for this session
console.warn: SearchSettings: "get: No settings file exists, new profile?" (new NotFoundError("Could not open the file at C:\\Users\\Swapnil\\AppData\\Local\\Temp\\rust_mozprofilem8DR7S\\search.json.mozlz4", (void 0)))
DevTools listening on ws://127.0.0.1:56027/devtools/browser/ca340c26-2e70-4f00-9119-00c946912a74
1672138109317	Marionette	INFO	Stopped listening on port 56038
JavaScript error: resource://gre/modules/UrlClassifierListManager.jsm, line 693: TypeError: this.tablesData[table] is undefined
console.warn: TopSitesFeed: Failed to fetch data from Contile server: NetworkError when attempting to fetch resource.
WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
sendPing@resource://gre/modules/EventPing.jsm:51:30
_submitPing@resource://gre/modules/EventPing.jsm:229:12
shutdown@resource://gre/modules/EventPing.jsm:112:10
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:940:31
shutdown/<@resource://gre/modules/TelemetryControllerParent.jsm:1010:24
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:982:34
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  Waiting for ping task
          Phase: TelemetryController: Waiting for pending ping activity
          State: (none)
WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:103:5
promiseArchivePing@resource://gre/modules/TelemetryArchive.jsm:63:33
_submitPingLogic@resource://gre/modules/TelemetryControllerParent.jsm:540:48
send@resource://gre/modules/TelemetryControllerParent.jsm:628:24
submitExternalPing@resource://gre/modules/TelemetryControllerParent.jsm:182:17
saveShutdownPings@resource://gre/modules/TelemetrySession.jsm:1014:36
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1232:20
cleanup@resource://gre/modules/TelemetrySession.jsm:1239:9
shutdownChromeProcess@resource://gre/modules/TelemetrySession.jsm:1256:14
shutdown@resource://gre/modules/TelemetrySession.jsm:247:17
_cleanupOnShutdown@resource://gre/modules/TelemetryControllerParent.jsm:959:35
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: A blocker encountered an error while we were waiting.
          Blocker:  TelemetryController: shutting down
          Phase: profile-before-change-telemetry
          State: Error getting state: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange" at addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
getShutdownState@resource://gre/modules/TelemetrySend.jsm:1687:7
getShutdownState@resource://gre/modules/TelemetrySend.jsm:369:30
_getState@resource://gre/modules/TelemetryControllerParent.jsm:1058:38
setupTelemetry/<@resource://gre/modules/TelemetryControllerParent.jsm:917:18
safeGetState@resource://gre/modules/AsyncShutdown.jsm:242:17
Barrier/addBlocker/promise<@resource://gre/modules/AsyncShutdown.jsm:751:20
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

WARNING: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
WARNING: addBlocker@resource://gre/modules/AsyncShutdown.jsm:703:15
addBlocker@resource://gre/modules/AsyncShutdown.jsm:511:26
addBlocker@resource://gre/modules/AsyncShutdown.jsm:450:15
setupShutdown@resource://gre/modules/osfile/osfile_async_front.jsm:1563:28
@resource://gre/modules/osfile/osfile_async_front.jsm:1583:16
@resource://gre/modules/osfile.jsm:12:30
@resource://gre/modules/TelemetryStorage.jsm:19:28
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:721:5
removeAbortedSessionPing@resource://gre/modules/TelemetryControllerParent.jsm:249:17
shutdownChromeProcess/cleanup/<@resource://gre/modules/TelemetrySession.jsm:1235:42
observe@resource://gre/modules/AsyncShutdown.jsm:560:16

JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
JavaScript error: resource://gre/modules/AsyncShutdown.jsm, line 703: Error: Phase "profile-before-change" is finished, it is too late to register completion condition "OS.File: flush I/O queued before profileBeforeChange"
